#!/usr/bin/env python

# The main JPF-Doop program file. It is used to run JPF-Doop to
# generate unit tests.

import os, sys, shutil
import argparse
import ConfigParser

from symbolize_tests import *
from generate_jpf_files import *
from command import *
from report import *

class ClassList:
    def __init__(self, filename):
        self.filename = filename
        self.list_of_classes = None

    def get_all_java_source_files(self, base, rootdir):
        """Finds all java files in a given directory tree and returns a list of such files"""

        if not self.list_of_classes == None:
            return self.list_of_classes

        ret = []
        
        for dirpath, dirnames, filenames in os.walk(os.path.join(base, rootdir)):
            for name in filenames:
                if name.endswith('.java'):
                    # No need to worry about abstract classes nor
                    # interfaces because Randoop will take care of
                    # that
                    ret.append(dirpath[len(os.path.normpath(base)) + 1:].replace("/", ".") + "." + name[:-len(".java")])

        self.list_of_classes = ret

        return ret

    def write_list_of_classes(self, root, rel_path):
        """Writes to a file a list of classes to be tested by JPFDoop"""

        with open(self.filename, 'w') as f:
            f.write("\n".join(self.get_all_java_source_files(root, rel_path)) + "\n")
        

class UnitTests:
    def __init__(self, name = "Randoop1Test", directory = "tests-round-1"):
        self.directory = directory
        self.name = name
        self.randooped_package_name = "randooped"

class Paths:
    def __init__(self):
        pass

class RandoopRun:
    def __init__(self, unit_tests_name, unit_tests_directory, classlist_filename, timelimit, paths, use_concrete_values = False):
        self.unit_tests_name = unit_tests_name
        self.unit_tests_directory = unit_tests_directory
        self.classlist_filename = classlist_filename
        self.unit_tests_timelimit = timelimit
        self.paths = paths
        self.use_concrete_values = use_concrete_values

    def run(self):

        # Remove previous unit tests
        
        shutil.rmtree(self.unit_tests_directory, ignore_errors = True)
        try:
            os.makedirs(self.unit_tests_directory)
        except:
            pass

        # Invoke Randoop. Check if it should use concrete values

        if not self.use_concrete_values:
            concrete_values_str = ""
        else:
            concrete_values_str = " --literals-file=concrete-values.txt --literals-level=ALL"

        command = Command(args = "java -ea -cp " + ":".join([self.paths.lib_randoop, self.paths.lib_junit, self.paths.sut_compilation_dir]) + " randoop.main.Main gentests --classlist=" + self.classlist_filename + " --junit-output-dir=" + self.unit_tests_directory + " --junit-classname=" + self.unit_tests_name + " --timelimit=%s" % self.unit_tests_timelimit +  " --forbid-null=false --small-tests=true --testsperfile=1" + concrete_values_str)

        command.run()

class JPFDoop:
    def __init__(self):
        pass
        self.paths = Paths()

    def read_config_file(self, config_file_name):
        config = ConfigParser.RawConfigParser()
        config.read(config_file_name)

        sections = ['jpfdoop', 'sut', 'tests', 'lib']
        for section in sections:
            if not config.has_section(section):
                sys.exit("The configuration file does not have the [" + section + "] section!")

        try:
            self.jpf_core_path = str(config.get('jpfdoop', 'jpf-core'))
            self.jpf_jdart_path = str(config.get('jpfdoop', 'jpf-jdart'))
            self.paths.sut_compilation_dir = str(config.get('sut', 'compilation-directory'))
            self.paths.tests_compilation_dir = str(config.get('tests', 'compilation-directory'))
            self.paths.lib_junit = str(config.get('lib', 'junit'))
            self.paths.lib_randoop = str(config.get('lib', 'randoop'))
            self.paths.lib_jacoco = str(config.get('lib', 'jacoco'))
        except Exception, err:
            print str(err) + " in " + config_file_name
            sys.exit(1)

    def run_randoop(self, unit_tests, classlist, params, use_concrete_values = False):
        """Invokes Randoop"""

        randoop_run = RandoopRun(unit_tests.name, unit_tests.directory, classlist.filename, str(params.rtimelimit), self.paths, use_concrete_values)
        randoop_run.run()

    def compile_tests(self, unit_tests):
        """Compiles unit tests generated by Randoop"""

        try:
            os.makedirs(self.paths.tests_compilation_dir)
        except:
            pass

        compile_tests_command = Command(args = "javac -g -d " + self.paths.tests_compilation_dir + " -cp " + ":".join([self.paths.sut_compilation_dir, self.paths.lib_junit]) + " " + unit_tests.directory + "/*java")
        compile_tests_command.run()

    def compile_symbolic_tests(self, root_dir, unit_tests):
        """Compiles JDart-modified symbolic unit tests"""

        try:
            os.makedirs(self.paths.tests_compilation_dir)
        except:
            pass

        compile_tests_command = Command(args = "javac -g -d " + self.paths.tests_compilation_dir + " -cp " + ":".join([os.path.join(self.jpf_jdart_path, "build"), os.path.join(self.jpf_jdart_path, "build/annotations/"), self.paths.sut_compilation_dir, self.paths.tests_compilation_dir, self.paths.lib_junit]) + " " + os.path.join("./", unit_tests.randooped_package_name +  "/*java"))
        compile_tests_command.run()

    def select_unit_test_files(self, unit_tests, count):

        import re, random

        # Instead of relying on
        # <unit_tests.randooped_package_name>0.java only, list all
        # Java files with unit tests, select <count> of them at
        # random, and process them. Now there is one method per Java
        # file

        dir_list = os.listdir(unit_tests.directory)

        prog = re.compile(unit_tests.name + "[0-9]+\.java")
        unit_tests_list = filter(prog.match, dir_list)

        print "# of unit tests: %d" % len(unit_tests_list)

        # Now select only <count> of them

        if count > len(unit_tests_list):
            unit_tests_indices = [i for i in range(len(unit_tests_list))]
            # create a list of all numbers 0..
        else:
            unit_tests_indices = random.sample(range(len(unit_tests_list)), count)

        # print unit_tests_indices

        return unit_tests_indices

    def symbolize_unit_tests(self, unit_tests, count):
        """Replaces concrete method input values with symbolic variables in unit tests"""

        unit_test_indices = self.select_unit_test_files(unit_tests, count)

        print "count: %d" % count
        print unit_test_indices

        # Remove the file with class names
        try:
            os.remove(os.path.join(unit_tests.randooped_package_name, "classes-to-analyze"))
        except OSError, e:
            pass

        for unit_test_index in unit_test_indices:
            # Something is wrong here with this classes-to-analyze. Or
            # maybe not... probably whenever there is a new unit test,
            # it just gets appended to the file. Check that

            symbolic_unit_tests = SymbolicUnitTests(unit_tests.randooped_package_name, "classes-to-analyze", os.path.join(unit_tests.directory, unit_tests.name + str(unit_test_index) +'.java'), ['test' + str(unit_test_index) + 'Class'])
            symbolic_unit_tests.generate_symbolized_unit_tests()

    def generate_jpf_conf(self, unit_tests, root_dir):
        """Generates JPF configuration files (.jpf) for JDart"""
        
        jpf_configuration_files = CoordinateConfFileGeneration(unit_tests.randooped_package_name, 'classes-to-analyze', ",".join([self.paths.tests_compilation_dir, self.paths.lib_junit]))
        jpf_configuration_files.run()

    def run_jdart(self, unit_tests, root_dir):
        """Calls JDart on the symbolized unit tests"""

        with open(os.path.join(unit_tests.randooped_package_name, "classes-to-analyze")) as f:
            for line_nl in f:
                class_name = line_nl[:-1]

                whole_path = os.path.join(unit_tests.randooped_package_name, class_name + ".jpf")

                jdart = CommandWithTimeout(cmd=os.path.join(self.jpf_core_path, "bin/jpf"), args=os.path.join(self.jpf_core_path, "bin/jpf") + " " + whole_path)
                jdart.run(timeout=20)

    def put_class_name(self, classlist, root_dir, path):
        """Replaces a placeholder with a valid class name in the file with concrete values"""

        put_class_name_command = Command(args = "python put-class-name.py --classname %s" % classlist.get_all_java_source_files(root_dir, path)[0])
        put_class_name_command.run()

    def run_code_coverage(self, unit_tests_list, package_path):
        """Runs JaCoCo on all unit tests from the list and generates a code coverage report"""

        # Run tests for all unit test sets but the last one
        for uts in unit_tests_list[:-1]:
            code_coverage_command = Command(args = "ant -f jacoco.xml -Darg0=%s -Darg1=%s test" % (uts.name, package_path))
            code_coverage_command.run()

        # Run tests for the last unit test set and generate a report
        report_command = Command(args = "ant -f jacoco.xml -Darg0=%s -Darg1=%s report" % (unit_tests_list[-1].name, package_path))
        report_command.run()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generates unit tests with Randoop only or with JPF-Doop.')
    parser.add_argument('--packagename', required=True, help='A Java package with classes to analyze.')
    parser.add_argument('--root', default='src/examples/', help='source files root directory')
    parser.add_argument('--classlist', default='classlist.txt', help='Name of a file to write a file list to')
    parser.add_argument('--rtimelimit', default=30, help='Timelimit for a single run of Randoop')
    parser.add_argument('--runittests', default=20, type=int, help='Upper limit of number of unit tests Randoop will generate in a single run')
    parser.add_argument('--conffile', default='jpfdoop.ini', help="A configuration file with settings for JPF-Doop")
    params = parser.parse_args()

    jpfdoop = JPFDoop()
    jpfdoop.read_config_file(params.conffile)
    jpfdoop.paths.package_path = os.path.normpath(params.packagename.replace(".", "/"))

    # Create a list of classes to be tested
    classlist = ClassList(params.classlist)
    classlist.write_list_of_classes(params.root, jpfdoop.paths.package_path)

    unit_tests = UnitTests(name = "Randoop1Test", directory = "tests-round-1")

    # Invoke Randoop to generate unit tests
    jpfdoop.run_randoop(unit_tests, classlist, params)

    # Symbolize unit tests
    jpfdoop.symbolize_unit_tests(unit_tests, params.runittests)

    # Generate JPF configuration files
    jpfdoop.generate_jpf_conf(unit_tests, params.root)

    # Compile symbolized unit tests
    jpfdoop.compile_symbolic_tests(params.root, unit_tests)

    # Run JDart on symbolized unit tests
    jpfdoop.run_jdart(unit_tests, params.root)

    # Replace a placeholder with a valid class name in the file with
    # concrete values
    jpfdoop.put_class_name(classlist, params.root, jpfdoop.paths.package_path)

    unit_tests2 = UnitTests(name = "Randoop2Test", directory = "tests-round-2")

    # Run Randoop for the second time
    jpfdoop.run_randoop(unit_tests2, classlist, params, use_concrete_values = True)
    
    # Compile tests generated by Randoop
    jpfdoop.compile_tests(unit_tests)
    jpfdoop.compile_tests(unit_tests2)
    
    # Generate a code coverage report
    unit_tests_list = [unit_tests.name, unit_tests2.name]
    classpath = ":".join([jpfdoop.paths.lib_junit, jpfdoop.paths.sut_compilation_dir, jpfdoop.paths.tests_compilation_dir])
    report = Report(jpfdoop.paths.lib_jacoco, unit_tests_list, os.path.normpath(jpfdoop.paths.package_path), classpath, params.root, jpfdoop.paths.sut_compilation_dir)
    report.run_code_coverage()
